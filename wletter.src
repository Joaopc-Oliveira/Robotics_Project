&ACCESS RVP
&REL 10
&PARAM EDITMASK = *
&PARAM TEMPLATE = C:\KRC\Roboter\Template\vorgabe
&PARAM DISKPATH = KRC:\R1\Program\Projekte

DEF writingLetters( )

   DECL INT I
   DECL CHAR TEXT[32]

   BAS (#INITMOV,0)

   ; Tool/Base (ajusta para os teus Ã­ndices)
   $TOOL = TOOL_DATA[14]
   $BASE = BASE_DATA[14]

   ; Motion tuning
   $VEL.CP   = DRAW_VEL_CP
   $ACC.CP   = DRAW_ACC_CP
   $APO.CDIS = BLEND_CDIS
   $ADVANCE  = ADVANCE_RUN

   ; Home
   PTP XHOME

   ; Go to start area (safe Z up)
   LIN START_POS
   LIN {X START_POS.X, Y START_POS.Y, Z Z_UP, A START_POS.A, B START_POS.B, C START_POS.C}

   ; --- Text source ---
   ; Option 1: edit TEXT in DAT by editing variable DEFAULT_TEXT[]
   ; Option 2: write here
   TEXT[] = DEFAULT_TEXT[]

   ; Reset writing offsets
   OFFSET_X = 0.0
   OFFSET_Y = 0.0

   ; Draw
   DrawText(TEXT[])

   ; Back to home
   PTP XHOME

END


; =========================
;  MAIN TEXT ROUTINE
; =========================
DEF DrawText(STR[] : IN)
   DECL CHAR STR[32]
   DECL INT K
   DECL CHAR CH

   FOR K = 1 TO STRLEN(STR[])
      CH = STR[K]

      ; ignore spaces
      IF CH == ' ' THEN
         NEXT_CHAR()
      ELSE
         DrawChar(CH)
         NEXT_CHAR()
      ENDIF
   ENDFOR
END


DEF DrawChar(CH : IN)
   DECL CHAR CH

   SWITCH CH
   CASE 'A'
      DRAW_A()
   CASE 'B'
      DRAW_B()
   CASE 'C'
      DRAW_C()
   CASE 'D'
      DRAW_D()
   CASE 'E'
      DRAW_E()
   CASE 'F'
      DRAW_F()
   DEFAULT
      ; unknown -> just skip
   ENDSWITCH
END


; =========================
;  SPACING
; =========================
DEF NEXT_CHAR()
   OFFSET_X = OFFSET_X + (CHAR_SPACING * SCALE)
   ; small lift to avoid dragging between chars
   LIN_REL {Z 20.0} C_DIS
END


; =========================
;  PEN CONTROL (Z UP/DOWN)
; =========================
DEF PEN_DOWN(GOAL :IN)
   DECL POS GOAL
   DECL POS P

   P = GOAL
   P.Z = Z_DOWN
   LIN P
END


DEF PEN_UP(GOAL :IN)
   DECL POS GOAL
   DECL POS P

   P = GOAL
   P.Z = Z_UP
   LIN P C_DIS
END


; Unified move to XY with current pen state coming from point flag
DEF MOVE_POINT(XY :IN, DOWN :IN)
   DECL POS XY
   DECL BOOL DOWN
   DECL POS P

   P = XY
   P.Z = Z_UP

   ; move above target with blending
   LIN P C_DIS

   IF DOWN THEN
      PEN_DOWN(P)
   ELSE
      PEN_UP(P)
   ENDIF
END


; =========================
;  LETTERS A-F
;  Each uses arrays in .DAT
; =========================
DEF DRAW_A()
   DECL INT I
   DECL POS T

   FOR I = 1 TO CHAR_A_N
      T = START_POS
      T.X = START_POS.X + OFFSET_X + (CHAR_A[I].X * SCALE)
      T.Y = START_POS.Y + OFFSET_Y + (CHAR_A[I].Y * SCALE)

      MOVE_POINT(T, CHAR_A[I].PEN_DOWN)
   ENDFOR

   PEN_UP(T)
END


DEF DRAW_B()
   DECL INT I
   DECL POS T

   FOR I = 1 TO CHAR_B_N
      T = START_POS
      T.X = START_POS.X + OFFSET_X + (CHAR_B[I].X * SCALE)
      T.Y = START_POS.Y + OFFSET_Y + (CHAR_B[I].Y * SCALE)

      MOVE_POINT(T, CHAR_B[I].PEN_DOWN)
   ENDFOR

   PEN_UP(T)
END


DEF DRAW_C()
   DECL INT I
   DECL POS T

   FOR I = 1 TO CHAR_C_N
      T = START_POS
      T.X = START_POS.X + OFFSET_X + (CHAR_C[I].X * SCALE)
      T.Y = START_POS.Y + OFFSET_Y + (CHAR_C[I].Y * SCALE)

      MOVE_POINT(T, CHAR_C[I].PEN_DOWN)
   ENDFOR

   PEN_UP(T)
END


DEF DRAW_D()
   DECL INT I
   DECL POS T

   FOR I = 1 TO CHAR_D_N
      T = START_POS
      T.X = START_POS.X + OFFSET_X + (CHAR_D[I].X * SCALE)
      T.Y = START_POS.Y + OFFSET_Y + (CHAR_D[I].Y * SCALE)

      MOVE_POINT(T, CHAR_D[I].PEN_DOWN)
   ENDFOR

   PEN_UP(T)
END


DEF DRAW_E()
   DECL INT I
   DECL POS T

   FOR I = 1 TO CHAR_E_N
      T = START_POS
      T.X = START_POS.X + OFFSET_X + (CHAR_E[I].X * SCALE)
      T.Y = START_POS.Y + OFFSET_Y + (CHAR_E[I].Y * SCALE)

      MOVE_POINT(T, CHAR_E[I].PEN_DOWN)
   ENDFOR

   PEN_UP(T)
END


DEF DRAW_F()
   DECL INT I
   DECL POS T

   FOR I = 1 TO CHAR_F_N
      T = START_POS
      T.X = START_POS.X + OFFSET_X + (CHAR_F[I].X * SCALE)
      T.Y = START_POS.Y + OFFSET_Y + (CHAR_F[I].Y * SCALE)

      MOVE_POINT(T, CHAR_F[I].PEN_DOWN)
   ENDFOR

   PEN_UP(T)
END
