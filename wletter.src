&ACCESS RVP
&REL 10
&PARAM EDITMASK = *
&PARAM TEMPLATE = C:\KRC\Roboter\Template\vorgabe
&PARAM DISKPATH = KRC:\R1\Program\Projekte

DEF writingLetters( )

   DECL CHAR TEXT[32]

   BAS (#INITMOV,0)

   ; Ajusta para os teus índices reais
   $TOOL = TOOL_DATA[14]
   $BASE = BASE_DATA[14]

   ; Motion tuning (valores vêm do .DAT)
   $VEL.CP   = DRAW_VEL_CP
   $ACC.CP   = DRAW_ACC_CP
   $APO.CDIS = BLEND_CDIS
   $ADVANCE  = ADVANCE_RUN

   ; HOME
   PTP XHOME

   ; Vai para origem do texto em Z seguro
   LIN START_POS
   LIN {X START_POS.X, Y START_POS.Y, Z Z_UP, A START_POS.A, B START_POS.B, C START_POS.C}

   ; Texto default
   TEXT[] = DEFAULT_TEXT[]

   ; Reset offsets
   OFFSET_X = 0.0
   OFFSET_Y = 0.0

   ; Desenhar
   DrawText(TEXT[])

   ; Volta HOME
   PTP XHOME

END


; =========================
;  MAIN TEXT ROUTINE
; =========================
DEF DrawText(STR[] : IN)
   DECL CHAR STR[32]
   DECL INT K
   DECL CHAR CH

   FOR K = 1 TO STRLEN(STR[])
      CH = STR[K]

      IF CH == ' ' THEN
         NEXT_CHAR()
      ELSE
         DrawChar(CH)
         NEXT_CHAR()
      ENDIF
   ENDFOR
END


DEF DrawChar(CH : IN)
   DECL CHAR CH

   SWITCH CH
   CASE 'A'
      DRAW_A()
   CASE 'B'
      DRAW_B()
   CASE 'C'
      DRAW_C()
   CASE 'D'
      DRAW_D()
   CASE 'E'
      DRAW_E()
   CASE 'F'
      DRAW_F()
   DEFAULT
      ; ignora caracteres não suportados
   ENDSWITCH
END


; =========================
;  SPACING
; =========================
DEF NEXT_CHAR()
   OFFSET_X = OFFSET_X + (CHAR_SPACING * SCALE)
   LIN_REL {Z 20.0} C_DIS
END


; =========================
;  PEN CONTROL (Z UP/DOWN)
; =========================
DEF PEN_DOWN(GOAL :IN)
   DECL POS GOAL
   DECL POS P

   P = GOAL
   P.Z = Z_DOWN
   LIN P C_DIS
END


DEF PEN_UP(GOAL :IN)
   DECL POS GOAL
   DECL POS P

   P = GOAL
   P.Z = Z_UP
   LIN P C_DIS
END


; Move para XY por cima e decide pen up/down
DEF MOVE_POINT(XY :IN, DOWN :IN)
   DECL POS XY
   DECL BOOL DOWN
   DECL POS P

   P = XY
   P.Z = Z_UP

   ; aproxima por cima com blending
   LIN P C_DIS

   IF DOWN THEN
      PEN_DOWN(P)
   ELSE
      PEN_UP(P)
   ENDIF
END


; =========================
;  LETTERS A-F
; =========================
DEF DRAW_A()
   DECL INT I
   DECL POS T

   FOR I = 1 TO CHAR_A_N
      T = START_POS
      T.X = START_POS.X + OFFSET_X + (CHAR_A[I].X * SCALE)
      T.Y = START_POS.Y + OFFSET_Y + (CHAR_A[I].Y * SCALE)
      MOVE_POINT(T, CHAR_A[I].PEN_DOWN)
   ENDFOR

   PEN_UP(T)
END


DEF DRAW_B()
   DECL INT I
   DECL POS T

   FOR I = 1 TO CHAR_B_N
      T = START_POS
      T.X = START_POS.X + OFFSET_X + (CHAR_B[I].X * SCALE)
      T.Y = START_POS.Y + OFFSET_Y + (CHAR_B[I].Y * SCALE)
      MOVE_POINT(T, CHAR_B[I].PEN_DOWN)
   ENDFOR

   PEN_UP(T)
END


DEF DRAW_C()
   DECL INT I
   DECL POS T

   FOR I = 1 TO CHAR_C_N
      T = START_POS
      T.X = START_POS.X + OFFSET_X + (CHAR_C[I].X * SCALE)
      T.Y = START_POS.Y + OFFSET_Y + (CHAR_C[I].Y * SCALE)
      MOVE_POINT(T, CHAR_C[I].PEN_DOWN)
   ENDFOR

   PEN_UP(T)
END


DEF DRAW_D()
   DECL INT I
   DECL POS T

   FOR I = 1 TO CHAR_D_N
      T = START_POS
      T.X = START_POS.X + OFFSET_X + (CHAR_D[I].X * SCALE)
      T.Y = START_POS.Y + OFFSET_Y + (CHAR_D[I].Y * SCALE)
      MOVE_POINT(T, CHAR_D[I].PEN_DOWN)
   ENDFOR

   PEN_UP(T)
END


DEF DRAW_E()
   DECL INT I
   DECL POS T

   FOR I = 1 TO CHAR_E_N
      T = START_POS
      T.X = START_POS.X + OFFSET_X + (CHAR_E[I].X * SCALE)
      T.Y = START_POS.Y + OFFSET_Y + (CHAR_E[I].Y * SCALE)
      MOVE_POINT(T, CHAR_E[I].PEN_DOWN)
   ENDFOR

   PEN_UP(T)
END


DEF DRAW_F()
   DECL INT I
   DECL POS T

   FOR I = 1 TO CHAR_F_N
      T = START_POS
      T.X = START_POS.X + OFFSET_X + (CHAR_F[I].X * SCALE)
      T.Y = START_POS.Y + OFFSET_Y + (CHAR_F[I].Y * SCALE)
      MOVE_POINT(T, CHAR_F[I].PEN_DOWN)
   ENDFOR

   PEN_UP(T)
END
